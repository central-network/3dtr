<!DOCTYPE html>
<html lang="en">
<head>
    <meta content="width=device-width, initial-scale=1" name="viewport" >
    <meta charset="UTF-8">
    <link rel="icon" href="./blueicon.ico">
    <script src="./coi-serviceworker.js"></script>
    <style>
        /*
        body, html { 
            width: 100vw; height: 100vh; overflow: hidden;
            margin: 0; overscroll-behavior-x: none;
            background-color: #08203f;
            pointer-events: none;
        }
        */

        body::after {
            content: attr(title);
            transform: translate(-70px, -100px) rotateZ(-90deg);
            position: fixed;
            left: 0;
            bottom: 0;
            color: rgb(0, 0, 0);
            font-family: Georgia, 'Times New Roman', Times, serif;
            font-size: 18px;
            white-space: nowrap;
        }

        #textview, #textdraw, #linedraw {
            width: 256px;
            height: 256px;
            position: absolute;
            z-index: 1;
            left: 50%;
            margin-left: -128px;
            background-color: white;
        }

        #textdraw {
            transform: translateY(110%);
        }
        
        #linedraw {
            transform: translateY(220%);
        }
    </style>

</head>
<body title="146.853.146.838 ops/sec" style=" height: 10000px; overflow: scroll; background-color: slateblue">    

<canvas id="textview" width="512" height="512"></canvas>
<canvas id="textdraw" width="512" height="512"></canvas>
<canvas id="linedraw" width="512" height="512"></canvas>
<script>
    let ctxread = textview.getContext("2d");
    let ctxdraw = textdraw.getContext("2d");
    let ctxline = linedraw.getContext("2d");

    ctxread.scale(devicePixelRatio, devicePixelRatio);
    ctxdraw.scale(devicePixelRatio, devicePixelRatio);
    ctxline.scale(devicePixelRatio, devicePixelRatio);

    ctxread.textRendering = "geometricPrecision";
    ctxread.font = "bold 256px serif";
    ctxread.textBaseline = "bottom";
    ctxread.textAlign = "middle";
    ctxdraw.fillStyle = "purple";
    ctxline.fillStyle = "fuchia";
    ctxline.strokeStyle = "red";

    let letter = "รถ";
    let textread = ctxread.measureText(letter);

    let tx = ((textview.width/devicePixelRatio) - (textread.width))/2 - 30;
    let ty = textread.fontBoundingBoxAscent //- 45;
    
    //ctxread.fillText(letter, tx, ty);
    ctxread.fillText(letter, tx, ty);

    console.log( "metrics:", textread, "textview.width:", textview.width, {tx, ty} )

    const getFontDraws = function ( imageData ) {
        let draws = [];
        let point;
        
        let readPerLine = imageData.width * 4;
        let [ i, r, g, b, a, y, x ] = [ 0, 0, 0, 0, 0, 0, 0 ];

        while ( i < imageData.data.length ) {
            
            [ r, g, b, a ] = imageData.data.subarray( i, i + 4 );
            
            if ( a === 0xff ) {

                point = {
                    i : draws.length,
                    row : x,
                    col : y,
                    m : Math.sqrt(
                        Math.pow( x/devicePixelRatio, 2 ) +
                        Math.pow( y/devicePixelRatio, 2 )
                    ),
                    x : x/devicePixelRatio,
                    y : y/devicePixelRatio,
                    a
                };

                draws[ point.i ] = point;

            }

            x += 1
            i += 4

            if (0 === i % readPerLine ) {
                y = 1 + y
                x = 0
            }
        }

        return draws;
    } 
    
    /*
    Array.prototype.transpose = function () {
        let transposed = [];
        let Instanceof = this[0].constructor; 
        let itemLength = this[0].length;


        for (let row=0; row < itemLength; row++) {
            for (let col=0; col < itemLength; col++) {
                if (!transposed[ col ]) {
                     transposed[ col ] = new Instanceof( itemLength );
                }
                transposed[ col ][ row ] = this[ row ][ col ];
            }
        }

        for (let row=0; row < itemLength; row++) {            
            for (let col=0; col < itemLength; col++) {
                this[ row ][ col ] = transposed[ row ][ col ];
            }
        }

        return this
    }

    const getFontDraws = function ( imageData ) {
        let draws = [];
        let point;
        
        let readPerLine = imageData.width * 4;
        let [ i, r, g, b, a, y, x ] = [ 0, 0, 0, 0, 0, 0, 0 ];

        while ( i < imageData.data.length ) {
            
            [ r, g, b, a ] = imageData.data.subarray( i, i + 4 );
            
            if ( a === 0xff ) {

                point = {
                    i : draws.length,
                    m : Math.sqrt(
                        Math.pow( x/devicePixelRatio, 2 ) +
                        Math.pow( y/devicePixelRatio, 2 )
                    ),
                    x : x/devicePixelRatio,
                    y : y/devicePixelRatio, 
                    a
                };

                draws[ point.i ] = point;

            }

            x += 1
            i += 4

            if (0 === i % readPerLine ) {
                y = 1 + y
                x = 0
            }
        }

        return draws;
    } 
    
    const readFontFills = function ( imageData ) {
        let read = []
        let readPerLine = imageData.width * 4;
        let buffer = new self.ArrayBuffer( imageData.width * imageData.height );
        let [ i, r, g, b, a, y, x ] = [ 0, 0, 0, 0, 0, 0, 0 ];

        while ( i < imageData.data.length ) {
            
            [ r, g, b, a ] = imageData.data.subarray( i, i + 4 );

            if(!read[y]) {
                byteOffset = imageData.width * (i/imageData.width/4);
                read[y] = new self.Uint8Array( buffer, byteOffset, imageData.width );
            }
            
            if ( a === 0xff ) {
                read[y][x] = a;
            }

            x += 1
            i += 4

            if (0 === i % readPerLine ) {
                y = 1 + y
                x = 0
            }
        }

        return read;
    } 

    const clearGroups = function ( reads ) {

        let pos;

        for ( let row=0; row < reads.length; row++ ) {
            pos = 0;
            while ( (pos = reads[ row ].findIndex( (c, p) => c && p > pos )) > 0  ) {
                reads[ row ].fill( 0, ++pos, -1 + reads[ row ].indexOf(0, pos) )
            }
        }

        return reads;


        reads.transpose()

        for ( let row=0; row < reads.length; row++ ) {
            pos = 0;
            while ( (pos = reads[ row ].findIndex( (c, p) => c && p > pos )) > 0  ) {
                reads[ row ].fill( 0, ++pos, -1 + reads[ row ].indexOf(0, pos) )
            }
        }

        reads.transpose()

        return reads
    }

    const findGroups = function ( reads ) {

        let groups = 0;

        for ( let row=4; row < reads.length-4; row++ ) {
            for ( let col=4; col < reads[row].length-4; col++ ) {

                if (reads[row][col] !== 0xff ) {
                    continue;
                }

                let searchs = [
                    (row) , (col - 1),              // prev
                    (row - 1) , col,                // above
                    (row - 1) , (col - 1),          // above prev
                    (row - 1) , (col + 1),          // above next
                    (row + 1) , (col),              // below
                    (row + 1) , (col - 1),          // below prev
                    (row) , (col + 1),              // next
                    
                    (row) , (col - 2),              // prev
                    (row - 2) , col,                // above
                    (row - 2) , (col - 2),          // above prev
                    (row - 2) , (col + 2),          // above next
                    (row + 2) , (col),              // below
                    (row + 2) , (col - 2),          // below prev
                    (row) , (col + 2),              // next
                ];

                for ( let s=0; s<searchs.length; s+=2 ) {
                    let group = reads[ searchs[s] ][ searchs[s+1] ];
                    if (group % 0xff) {
                        reads[row][col] = group;
                        break;
                    }
                }

                if ( reads[row][col] === 0xff ) {
                    reads[row][col] = groups++;
                }
            }
        }

        reads.transpose()

        for ( let row=4; row < reads.length-4; row++ ) {
            for ( let col=4; col < reads[row].length-4; col++ ) {
                if (reads[row][col] === 0 ) {
                    continue;
                }

                let searchs = [
                    (row) , (col - 1),              // prev
                    (row - 1) , col,                // above
                    (row - 1) , (col - 1),          // above prev
                    (row - 1) , (col + 1),          // above next
                    (row + 1) , (col),              // below
                    (row + 1) , (col - 1),          // below prev
                    (row) , (col + 1),              // next
                    
                    (row) , (col - 2),              // prev
                    (row - 2) , col,                // above
                    (row - 2) , (col - 2),          // above prev
                    (row - 2) , (col + 2),          // above next
                    (row + 2) , (col),              // below
                    (row + 2) , (col - 2),          // below prev
                    (row) , (col + 2),              // next
                ];

                for ( let s=0; s<searchs.length; s+=2 ) {
                    let group = reads[ searchs[s] ][ searchs[s+1] ];
                    if (group) {
                        reads[row][col] = group;
                        break;
                    }
                }
            }
        }

        reads.reverse()

        for ( let row=4; row < reads.length-4; row++ ) {
            for ( let col=4; col < reads[row].length-4; col++ ) {
                if (reads[row][col] === 0 ) {
                    continue;
                }

                let searchs = [
                    (row) , (col - 1),              // prev
                    (row - 1) , col,                // above
                    (row - 1) , (col - 1),          // above prev
                    (row - 1) , (col + 1),          // above next
                    (row + 1) , (col),              // below
                    (row + 1) , (col - 1),          // below prev
                    (row) , (col + 1),              // next
                    
                    (row) , (col - 2),              // prev
                    (row - 2) , col,                // above
                    (row - 2) , (col - 2),          // above prev
                    (row - 2) , (col + 2),          // above next
                    (row + 2) , (col),              // below
                    (row + 2) , (col - 2),          // below prev
                    (row) , (col + 2),              // next
                ];

                for ( let s=0; s<searchs.length; s+=2 ) {
                    let group = reads[ searchs[s] ][ searchs[s+1] ];
                    if (group) {
                        reads[row][col] = group;
                        break;
                    }
                }
            }
        }

        reads.reverse()
        reads.transpose()

        return reads;
    }


    let imageData = ctxread.getImageData(0, 0, textview.width, textview.height);

    let read = readFontFills( imageData );
    console.log(read)
    clearGroups( read )
    findGroups( read )

    let ascii = "";

    for (let i=0; i< read.length; i++) {
        ascii = ascii + read[i].join("").replace(/0/g, " ") + "\n"
    }
    console.log( ascii )


    //findGroups( read.transpose() )
    //console.log(read.transpose())

    */

    let imageData = ctxread.getImageData(0, 0, textview.width, textview.height);
    let draws = getFontDraws( imageData );

    draws.forEach( ({ x, y }) => {
        ctxdraw.fillRect( x, y, 1, 1 );
    });



    queueMicrotask(function (){

        console.log("calculating distances... draws:", draws.length);

        for ( let i=1; i<draws.length; i++ ) {
            draws[i].d = Math.sqrt(
                Math.pow( ( draws[i].x - draws[i-1].x ), 2 ) +
                Math.pow( ( draws[i].y - draws[i-1].y ), 2 )
            )
        }
        
        draws = Object.groupBy(draws, d => d.d < 1 ).true;

        let groups = [
            [ draws.splice(0,1)[0] ]
        ]

        i = 0;
        
        console.log("creating groups...");
        for ( let i=0; i<draws.length; i++ ) {

            let found = false;

            for ( let p=0; p<groups.length; p++ ) {

                for ( let g=0; g<groups[p].length; g++ ) {

                    d = Math.sqrt(
                        Math.pow( ( groups[p][g].x - draws[i].x ), 2 ) +
                        Math.pow( ( groups[p][g].y - draws[i].y ), 2 )
                    )

                    m = Math.sqrt(
                        Math.pow( ( groups[p][g].m - draws[i].m ), 2 )
                    )

                    if ( d < 1 ) {
                        groups[p].push(draws[i])
                        found = true;
                        break;
                    }
                }

                if (found) {
                    break;
                }
            }

            if (!found) {
                groups.push([draws[i]])
            }
        }

        let len0 = groups.length;
        let len1 = groups.length;

        i = 0;
        j = 0;
         
        const mergeGroups = function ( i = 0 ) {

            if (!groups.find( (g) => g.length < 500 )) {
                return groups;
            }
            
            if (groups[i]){

                let group0 = groups[i];
                group0.inloop = 1;

                groups.forEach( ( group1 ) => {
                    if ( group1 && !group1.inloop && ( group0 !== group1 ) ) {
                        for (let p=0; p<group0.length; p++ ) {
                            let point0 = group0[p];
                            
                            for (let l=0; l<group1.length; l++ ) {
        
                                let point1 = group1[l];
                                
                                d = Math.sqrt(
                                    Math.pow( ( point0.x - point1.x ), 2 ) +
                                    Math.pow( ( point0.y - point1.y ), 2 )
                                )
        
                                if ( d < 1 ) {
                                    group0.push( ...group1.splice(0) );
                                    return;
                                }
                            }                    
                        }
                    }
                })

                group0.inloop = 0;
            }

            groups = groups.filter(g => g.length);

            if (len0 === ++i) {
                return groups;
            }

            console.warn("merging groups...", groups.length);
            return mergeGroups(i)
        }

        const cleanGroups = function () {
            groups.forEach(function ( group, i ){
                group.sort( (a,b) => {
                    if ( a.row > b.row ) {
                        return 3
                    } else if ( a.row === b.row ) {
                        if ( a.col > b.col ) {
                            return 1
                        } else { return -2 }
                    } else { return -1 }
                })
            })


            groups.forEach(function ( group, g ){

                let i, begin, end, splices;

                i = 0;
                splices = []
                while ( i < group.length ) {

                    if (!group[i-1]) {
                        begin = end = i++
                        continue
                    }

                    if ( group[i].row === group[i-1].row ) {
                        if ( group[i].col !== group[i-1].col + 1 ) {
                            splices.push( [ ++begin, end ] )
                            begin = i
                        }
                    }
                    else {
                        splices.push( [ ++begin, end ] )
                        begin = i
                    }

                    end = i
                    i++
                }

                splices.forEach( ([begin, end]) => group.fill(false, begin, end ) )
                splices.length = 0
                groups[g] = group.filter(Boolean)

            })


            groups.forEach(function ( group, i ){
                group.sort( (a,b) => {
                    if ( a.col > b.col ) {
                        return 3
                    } else if ( a.col === b.col ) {
                        if ( a.row > b.row ) {
                            return 1
                        } else { return -2 }
                    } else { return -1 }
                })
            })

            groups.forEach(function ( group, g ){

                let i, begin, end, splices;

                i = 0;
                splices = []
                while ( i < group.length ) {

                    if (!group[i-1]) {
                        begin = end = i++
                        continue
                    }

                    if ( group[i].col === group[i-1].col ) {
                        if ( group[i].row !== group[i-1].row + 1 ) {
                            splices.push( [ ++begin, end ] )
                            begin = i
                        }
                    }
                    else {
                        splices.push( [ ++begin, end ] )
                        begin = i
                    }

                    end = i
                    i++
                }

                splices.forEach( ([begin, end]) => group.fill(false, begin, end ) )
                splices.length = 0
                groups[g] = group.filter(Boolean)

            })

        }



        console.groupCollapsed("merging groups...");
        mergeGroups();
        mergeGroups(3);
        console.groupEnd();

        
        console.groupCollapsed("cleaning groups...");
        cleanGroups();
        console.groupEnd();


        let colors = [
            "red", "blue", "green", "aqua", "brown", "chartreuse", "gray", "black"
        ]

        groups.forEach(function ( group, i ){
            ctxline.fillStyle = colors[ i% 8 ];
            group.forEach(function ({ x, y }){
                ctxline.fillRect( x, y, 1, 1 );
            })
        })

        console.log(groups)
    })





    /*
    let groups = [ draws ];

    groups = groups.filter( g => g.length > 10 )

    groups.forEach( (group, j) => {

        group = groups[j].sort( (a,b) => {
            return Math.sqrt(
                Math.pow( ( a.x - b.x ), 2 ) +
                Math.pow( ( a.y - b.y ), 2 )
            )
        })

        console.warn( "group:" + j, group );
        
        for ( let i=0; i<group.length; i+=2 ) {
            ctxline.strokeStyle = colors[(i/2)%8]
            ctxline.beginPath();
            ctxline.moveTo(
                group[i].x,
                group[i].y
            );
            if (group[i+1]) {
                ctxline.lineTo(
                    group[i+1].x,
                    group[i+1].y
                );
            }
            ctxline.closePath();
            ctxline.stroke();
        }

    })


*/


    /*

    let pairs = [];
    let dist0;
    let dist1;
    let diff;
    let x1, y1;
    let closest;

    let max = 42;
    let dlen = draws.length;
    let reversed = false;

    console.log("draws.length:", draws)

    findClosest = function (i = 0) {

        i = Math.abs(i);

        if (!draws[i]) {
            throw pairs;
        }

        let { x: x0, y: y0, i: i0 } = draws[i];
        let _len = draws.length;

        let dy0 = Math.sqrt( y0*y0 );
        let dx0 = Math.sqrt( x0*x0 );
        let d0  = Math.sqrt( x0*x0 + y0*y0 );

        let dists = [];

        let k;

        if ( reversed ) {
            k = _len-1;
        }
        else {
            k = i + 1
        }

        let inloop = draws[ k ].x;        

        while ( inloop ) {

           
            if ( reversed ) {
                
                if ( !draws[ --k ] ) {
                    inloop = false;
                }
            }
            else {
                if ( !draws[ k++ ] ) {
                    inloop = false;
                    reversed = true;
                }
            }

            if (!draws[ k ]) {
                if (!k) {
                    break;
                }
                continue;
            }

            let { x: x1, y: y1, i: i1, paired: p } = draws[ k ];

            let dy1 = Math.sqrt( y1*y1 );
            let dx1 = Math.sqrt( x1*x1 );
            let d1  = Math.sqrt( x1*x1 + y1*y1 );

            let dy = Math.abs( dy1 - dy0 );
            let dx = Math.abs( dx1 - dx0 );
            let d  = Math.sqrt(
                Math.pow( x1 - x0, 2 ) + 
                Math.pow( y1 - y0, 2 )
            );

            if (d && d < 6.4 && !p) {
                dists.push({
                    i: i1, d, x: x1, y: y1
                });
            }
        }

        if ( dists.length === 0 ) {
            if ( reversed ) {
                return;
            }
            else {
                return findClosest( i );
            }
        }

        dists.sort(function ( a, b ){
            if ( a.dy > b.dy ) {
                return +1;
            }
            return -1;
        });

        let dsy = dists[0].y;
        
        dists = dists
            .filter( d => d.y === dsy )
            .sort(function ( a, b ){
            if ( a.d > b.d ) {
                return +1;
            }
            return -1;
        });


        let closests = dists;
        let closest = closests.at(0);

        if (!closest) {
            return;
        }


        pairs.push( {
            from : { i: i0, x: x0, y: y0 },
            to : { i: closest.i, x: closest.x, y: closest.y  }
        })

        draws[i0].paired = 1;

        if (--dlen) {
            return findClosest( closest.i );
        }
    }


    findClosest(0)

    ctxline.beginPath();
    ctxline.strokeStyle = "green";

    let plen = pairs.length;

    while( plen-- ) {
        ctxline.moveTo(
            pairs[plen].from.x,
            pairs[plen].from.y
        );

        ctxline.lineTo(
            pairs[plen].to.x,
            pairs[plen].to.y
        );
    }

    ctxline.stroke();
    console.log( pairs )
    */

</script>


<!--
<script src="3dtr.js">

    new Uint8Array( Math.trunc(performance.now()) );
    const screen = new OnscreenCanvas();
    let red = 0.1, green = 0.3 , blue= 0.9, sign = 1, factor = 0.002;


    screen.render(function (gl){

        red += (factor * sign);
        green += (factor * sign);
        blue += (factor * sign); 

        if ( red > 1 || red < 0 ) { sign *= -1; }
        if ( green > 1 || green < 0 ) { sign *= -1; }
        if ( blue > 1 || blue < 0 ) { sign *= -1; }

        gl.clearColor( red, green, blue, 1 );
        gl.clear(gl.COLOR_BUFFER_BIT);

        
    });
    
  
    log({ screen });

</script>
-->
</body>
</html>